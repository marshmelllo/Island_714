<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_zombie</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*after done, set this in creation code of object*/ mood="idol" //can be either idol, spotted, patrol or seen

global.mpgrid=mp_grid_create(0,0,room_width/32,room_height/32,32,32)//setting the grid for the pathfinding ai
mp_grid_add_instances(global.mpgrid,solid_par,true);
mp_grid_add_instances(global.mpgrid,obj_sandbags,true);
mypath=path_add();
image_speed=0.3
lastX=player.x;
lastY=player.y;
start=true;
hp=100;
deadObj=zombie_dead
daze=false;
canHit=true;
image_angle=random(360)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>daze=false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>canHit=true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///when zombie sees you
//pathfinding AI
if(player.dead=false){
if(mood="spotted"){
dx=floor(player.x/16)*16+8;
dy=floor(player.y/16)*16+8;

if !mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true) //This is debugging to make sure a path exists...
    {
    var i,x2,y2; //Temp variables...
    var x1=x;
    var y1=y;
    for (i=0; i&lt;path_get_number(mypath); i+=1) //This loops through all the path points...
        {
        x1=path_get_point_x(mypath,i); //These lines add the path points to temp variables
        y1=path_get_point_y(mypath,i); //to be checked later on...
        x2=path_get_point_x(mypath,i+1);
        y2=path_get_point_y(mypath,i+1);
        if collision_line(x1,y1,x2,y2,solid_par,false,true) //checks to see if there is a collision between adjacent path points...
            {
            if(x1=0&amp;&amp;y1=0){mood="idol";path_end();break;}
            else{
            dx=x1; //If there is a collision, it sets dx/y to the last "good" path point...
            dy=y1;
            break;
            }
            }
        } 
    mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,1); //This now re_creates the path with the "good" coords...
    path_start(mypath,4,0,1); //This starts the object moving on the path...
    }
else
    {
    mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,1); //This now creates the path...
    path_start(mypath,4,0,1); //This starts the object moving on the path...
    }
    
    }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///when zombie saw you but no longer sees you
if(player.dead=false)
if(mood="seen"){
dx=floor(lastX/16)*16+8;
dy=floor(lastY/16)*16+8;

if !mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true) //This is debugging to make sure a path exists...
    {
    var i,x2,y2; //Temp variables...
    var x1=x;
    var y1=y;
    for (i=0; i&lt;path_get_number(mypath); i+=1) //This loops through all the path points...
        {
        x1=path_get_point_x(mypath,i); //These lines add the path points to temp variables
        y1=path_get_point_y(mypath,i); //to be checked later on...
        x2=path_get_point_x(mypath,i+1);
        y2=path_get_point_y(mypath,i+1);
        if collision_line(x1,y1,x2,y2,solid_par,false,true) //checks to see if there is a collision between adjacent path points...
            {
            if(x1=0&amp;&amp;y1=0){mood="idol";path_end();break;}
            else{
            dx=x1; //If there is a collision, it sets dx/y to the last "good" path point...
            dy=y1;
            break;
            }
            }
        } 
    mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,1); //This now re_creates the path with the "good" coords...
    path_start(mypath,3.5,0,1); //This starts the object moving on the path...
    }
else
    {
    mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,1); //This now creates the path...
    path_start(mypath,3.5,0,1); //This starts the object moving on the path...
    }
    
    }
    //Check to see if zombie is at position where last seen player
if(distance_to_point(lastX,lastY)&lt;5){
mood="idol";
start=false
lookDir=point_direction(x,y,player.x,player.y)
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///other

if!(mood="idol"){
turn=12;
image_angle += median(-turn, turn, ((((direction - image_angle) mod 360) + 540) mod 360) - 180);
}
if(hp&lt;=0){
with(bandit){
if(other.id = target){
mood="idol";
start=true;
target=self;
}
}

//splat=instance_create(x,y,blood_splat); splat.image_angle=point_direction(x,y,player.x,player.y)
instance_create(x,y,blood)
instance_destroy();
}
if(daze){
speed=0;
}
if(distance_to_object(instance_nearest(x,y,obj_door))&lt;25 &amp;&amp; abs(path_speed)&gt;1){
with(instance_nearest(x,y,obj_door)){if(open=false)doorOpen(self,-1)}
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///checking for player
if(player.dead=false)
for(var i = -45; i&lt;45; i++){
if(collision_line(x,y,x+lengthdir_x(2000,image_angle+i),y+lengthdir_y(2000, image_angle+i),player,1,0)){
if!(collision_line(x,y,player.x,player.y,solid_par,1,0)){
if!(collision_line(x,y,player.x,player.y,obj_door,1,0)){
mood="spotted";
lastX=player.x
lastY=player.y
break;
}
}
}
else if(mood="spotted"){mood="seen"}
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///idol
if(mood="idol"){
image_speed=0;
if(start){
image_angle+=2;
}
else{

if(abs(lookDir-image_angle) = 0 || abs(lookDir-image_angle)=360){
start=true;
}else{
turn=12;
image_angle += median(-turn, turn, ((((lookDir - image_angle) mod 360) + 540) mod 360) - 180);}


}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="explosion">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(other.image_index)&lt;5{
hp=0;
if(hp&lt;=0){
body=instance_create(x,y,deadObj);
body.image_angle=image_angle
repeat(3){
instance_create(x,y,blood_spray)
instance_create(x,y,blood_mist)
instance_create(x,y,blood_drip)
}
repeat 6{
ID=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),hit_blood);
ID.image_angle=random(360)
with (ID)motion_set(image_angle+200-10+random(20),6+random(3));
}
repeat 2{
ID=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),blood_drip);
ID.image_angle=random(360)
with (ID)motion_set(image_angle+200-10+random(20),2+random(2));
}
repeat 2{
ID2=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),hit_splat);
ID2.image_angle=random(360)
with (ID2)motion_set(image_angle+200-10+random(20),2+random(1));
}
repeat 2{
ID2=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),hit_splat2);
ID2.image_angle=random(360)
with (ID2)motion_set(image_angle+200-10+random(20),2+random(1));
}

}}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="zombie">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if x&gt;other.x x+=1; else x-=1; if y&gt;other.y y+=1; else y-=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(canHit &amp;&amp;player.dead=false){

speed=0
path_end();
canHit=false
alarm[0]=30
player.hp-=20
player.lastHit=0;
var angel = image_angle
with(player){
audio_play_sound(sound_zombie_hit,10,0);
instance_create(x,y,blood_spray)
instance_create(x,y,blood_mist)
instance_create(x,y,blood_drip)

repeat 4{
ID=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),hit_blood);
ID.image_angle=angel
with (ID)motion_set(image_angle+200-10+random(20),6+random(3));
}

repeat 2{
ID2=instance_create(x+lengthdir_x(20,direction),y+lengthdir_y(20,direction),hit_splat);
ID2.image_angle=angel
with (ID2)motion_set(image_angle+200-10+random(20),2+random(1));
}
if(hp&lt;=0 &amp;&amp; dead=false &amp;&amp; !instance_exists(player_dead))
{
body=instance_create(x,y,deadObj);
body.image_angle=angel
}
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index,image_index,x+6,y+6,1,1,image_angle,c_black,0.5)
draw_self();
//draw_path(mypath,x,y,1)
/*
for(var i = -45; i&lt;45; i++){
draw_line(x + lengthdir_x(gun[8], image_angle) - lengthdir_y(0, image_angle),y + lengthdir_y(gun[8], image_angle) + lengthdir_x(0, image_angle),x+lengthdir_x(2000,image_angle+i),y+lengthdir_y(2000, image_angle+i))
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>18,24</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
